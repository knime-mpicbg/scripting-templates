# name: estimate gaussion intersection
# author: Felix Meyenhofer
# category: statistics
# preview: gaussian-intersection.png

compute the histograms of random variables, fit a gaussian and compute the intersection points.
(use the python figure template with the same name to produce the control plots)

######

<rgg>

<!--1. Title and short description -->

<h3 text="estimate gaussion intersection" aligment="center" span="full"/>
<separator label="Description" span="full"/>
<labelarea span="full">compute the histograms of random variables, fit a gaussian and compute the intersection points.

</labelarea>
<gaprow height="1"/>


<!-- 2. Configuration-->

<separator label="Options" span="full"/>
<gaprow height="2"/>

<group>
# a) Define your treatments of interest
strColName = <combobox label="Grouping column" items="$$$STR_ATTRIBUTES$$$" span="full"/>

# b) Define what numerical values to use
numColName = <combobox label="Numerical values" items="$$$NUM_ATTRIBUTES$$$" span="full"/>

# c) number of bins.
nBins = int(<textfield label="Number of bins" var="" data-type="number" default-value= "30" size="10" span="full"/>)
</group>


<!-- 3. Python script-->

<![CDATA[

import numpy as np
from scipy import optimize, integrate
#from matplotlib import pyplot
from scipy.optimize import fsolve


# Objective function to solve intersection
def fun(xy, f1, f2):
    x, y = xy
    z = np.array([y - f1(x), y - f2(x)])
    return z


def findIntersection(vect1, vect2):

    # make the histogram
    y1,x1 = np.histogram(vect1, bins=nBins, normed=True)
    y2,x2 = np.histogram(vect2, bins=nBins, normed=True)

    # calculate the center of the bins
    x1 = np.mean(np.column_stack((x1[:-1], x1[1:])).T,0)
    x2 = np.mean(np.column_stack((x2[:-1], x2[1:])).T,0)

    # estimate the parameter of the gaussian function
    mue1 = sum(x1*y1)/sum(y1)
    sig1 = np.sqrt(abs(sum((x1-mue1)**2*y1)/sum(y1)))
    a1 = y1.max()
    mue2 = sum(x2*y2)/sum(y2)
    sig2 = np.sqrt(abs(sum((x2-mue1)**2*y2)/sum(y2)))
    a2 = y2.max()

    # Fit
    fitfunc = lambda p, x: p[0]*np.exp(-(x-p[1])**2/(2*p[2]**2))       # Target function
    errfunc = lambda p, x, y: fitfunc(p, x) - y                     # Distance to the target function

    p0 = [a1, mue1, sig1]
    p1, success = optimize.leastsq(errfunc, p0[:], args=(x1, y1))
    g1 = lambda x : p1[0]*np.exp(-(x-p1[1])**2/(2*p1[2]**2))

    p0 = [a2, mue2, sig2]
    p2, success = optimize.leastsq(errfunc, p0[:], args=(x2, y2))
    g2 = lambda x : p2[0]*np.exp(-(x-p2[1])**2/(2*p2[2]**2))


    # Find the instersection.
    x0 = np.mean([mue1, mue2])
    y0 = g1(x0)
    intersection = fsolve(fun, [x0, y0], (g1, g2))

    # Compute overlap
    sig15 = sig1*5
    i1 = integrate.quad(g1, mue1-sig15, mue1+sig15)
    if mue1 > intersection[0]:
        o1 = integrate.quad(g1, mue1-sig15, intersection[0])
    else:
        o1 = integrate.quad(g1, intersection[0], mue1+sig15)

    sig25 = sig2*5
    i2 = integrate.quad(g2, mue1-sig25, mue1+sig25)
    if mue2 > intersection[0]:
        o2 = integrate.quad(g2, mue2-sig25, intersection[0])
    else:
        o2 = integrate.quad(g2, intersection[0], mue2+sig15)

    overlap = (o1[0] + o2[0]) / (i1[0] + i2[0])

    return (intersection[0], intersection[1], overlap, mue1, sig1, p1[1], p1[2], mue2, sig2, p2[1], p2[2])

#    # Control plot.
#    sigm = np.max([sig1, sig2])*4
#    muemi = np.min([mue1, mue2])
#    muema = np.max([mue1, mue2])
#    x = np.linspace(muemi-sigm, muema+sigm, 100)
#    plot(x, g1(x), 'b', x, g2(x), 'g', intersection[0], intersection[1], 'rx')


# pyOut = {'x coord.':[], 'y coord.':[], 'group a':[], 'mean(a) estimate':[], 'sd(a) estimate':[], 'mean(a) fit':[], 'sd(a) fit':[],
#                       'group b':[], 'mean(b) estimate':[], 'sd(b) estimate':[], 'mean(b) fit':[], 'sd(b) fit':[]}

pyOut = OrderedDict()
for key in ['x coord.', 'y coord.', '% overlap', 'group a', 'mean(a) estimate', 'sd(a) estimate', 'mean(a) fit', 'sd(a) fit','group b', 'mean(b) estimate', 'sd(b) estimate', 'mean(b) fit', 'sd(b) fit']:
	pyOut[key] = []


vec = kIn[numColName]
cat = kIn[strColName]

sets = {}
for index in range(0,len(vec)-1):
    if sets.has_key(cat[index]):
        sets[cat[index]].append(vec[index])
    else:
        sets[cat[index]] = [vec[index]]


keys = sets.keys()
numSets = len(keys)
for a in range(0, numSets-1):
    seta = sets[keys[a]]
    for b in range(a+1,numSets):
        setb = sets[keys[b]]
        data = findIntersection(seta, setb)
        pyOut['x coord.'].append(data[0])
        pyOut['y coord.'].append(data[1])
        pyOut['% overlap'].append(data[2])
        pyOut['group a'].append(keys[a])
        pyOut['mean(a) estimate'].append(data[3])
        pyOut['sd(a) estimate'].append(data[4])
        pyOut['mean(a) fit'].append(data[5])
        pyOut['sd(a) fit'].append(data[6])
        pyOut['group b'].append(keys[b])
        pyOut['mean(b) estimate'].append(data[7])
        pyOut['sd(b) estimate'].append(data[8])
        pyOut['mean(b) fit'].append(data[9])
        pyOut['sd(b) fit'].append(data[10])

]]>

</rgg>